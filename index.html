<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Shoes Gallery — Internal (admin)</title>
<style>
:root{--accent:#2b82c9;--header-bg:#e6f3ff}
body{font-family:system-ui,Arial;margin:0;background:#f0f6fb;color:#072033}
header{background:var(--header-bg);padding:12px 16px;box-shadow:0 2px 6px rgba(10,10,10,0.06);position:sticky;top:0;z-index:40}
.top-row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
.brand{font-weight:700;color:var(--accent)}
.controls-right{display:flex;gap:8px;align-items:center}
.search-wrap{flex:1 1 420px;margin-left:12px;min-width:160px;max-width:calc(100% - 260px)}
.search-input{width:100%;padding:8px 10px;border-radius:8px;border:1px solid rgba(0,0,0,0.08);font-size:14px;box-sizing:border-box}
.tabs{display:flex;gap:8px;overflow:auto;padding:8px;margin-top:8px}
.tab{padding:8px 12px;border-radius:8px;background:#eaf6ff;border:1px solid #d6ecff;cursor:pointer;white-space:nowrap}
.tab.active{background:var(--accent);color:white}
main{padding:12px}
.status{padding:8px 12px;color:#345}
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:10px}
.card{background:white;border-radius:8px;padding:8px;box-shadow:0 1px 4px rgba(12,15,30,0.06);text-align:center;display:flex;flex-direction:column;gap:8px;font-size:13px;position:relative}
.card img{width:100%;height:110px;object-fit:cover;border-radius:6px;cursor:pointer}
.checkbox-select{position:absolute;left:10px;top:10px;z-index:20;width:28px;height:28px;transform:scale(1.3);accent-color:var(--accent)}
.actions-bar{display:flex;gap:8px;align-items:center;margin-bottom:8px}
.btn{padding:6px 8px;border-radius:6px;border:1px solid #cbd5e1;background:transparent;cursor:pointer;font-size:13px}
.small{font-size:13px;color:#444}
.muted{color:#666;font-size:13px}
.section-title{margin:12px 0 8px;font-weight:600}
.modal{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;z-index:50;align-items:center;justify-content:center}
.modal.open{display:flex}
.modal-content{background:white;width:92%;height:86%;border-radius:12px;display:flex;flex-direction:column;overflow:auto}
.modal-header{padding:10px;border-bottom:1px solid #eee;display:flex;align-items:center;justify-content:space-between}
.modal-body{padding:10px;overflow:auto}
.two-col{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.two-col img{width:100%;height:auto;border-radius:6px;display:block}
@media(max-width:700px){.two-col{grid-template-columns:1fr}}
.barcode-strong{font-weight:700}
.header-actions { display:flex; gap:8px; align-items:center; }
.clear-key { font-size:12px; color:#b00; border:none; background:transparent; cursor:pointer; padding:4px; }
.progress-panel { position: fixed; right: 18px; bottom: 18px; width: 360px; max-width: calc(100% - 36px); background: rgba(255,255,255,0.98); border-radius:10px; box-shadow: 0 6px 20px rgba(0,0,0,0.12); padding:10px; z-index:120; font-size:13px; display:none; }
.progress-panel.open { display:block; }
.progress-row { margin-bottom:8px; }
.progress-bar-bg { width:100%; height:10px; background:#eee; border-radius:6px; overflow:hidden; }
.progress-bar-fill { height:100%; width:0%; background:var(--accent); border-radius:6px; transition: width 0.12s linear; }
.progress-label { font-size:12px; color:#333; margin-bottom:6px; display:flex; justify-content:space-between; align-items:center; gap:8px; }
.file-status { font-size:11px; color:#666; }
</style>
</head>
<body>
<header>
  <div class="top-row">
    <div style="display:flex;align-items:center;gap:10px">
      <div class="brand">Shoes Gallery — Internal</div>
      <div style="font-size:13px;color:#0b4d74">Chỉ nhân viên</div>
    </div>

    <div class="search-wrap">
      <input id="searchInput" class="search-input" placeholder="Tìm theo barcode (VD: 146888) — Enter để tìm" />
    </div>

    <div class="header-actions">
      <button id="refreshBtn" class="btn">Refresh manifest.json</button>
      <button id="clearKeyBtn" class="clear-key" title="Xóa Admin Key trong session">Clear Key</button>
    </div>
  </div>

  <div id="tabs" class="tabs"></div>
</header>

<main>
  <div id="status" class="status">Đang tải manifest...</div>

  <div id="selectActions" style="display:none;margin:8px 12px;">
    <div class="actions-bar">
      <div><strong>Chế độ xóa:</strong> Chọn các mục để xóa vĩnh viễn</div>
      <button id="deleteSelectedBtn" class="btn">Xóa đã chọn (vĩnh viễn)</button>
      <div style="margin-left:12px;" class="muted">Hành động không thể hoàn tác. Bạn sẽ nhập ADMIN_KEY (lưu trong session) khi thực hiện.</div>
    </div>
  </div>

  <div id="content"></div>
</main>

<!-- modal -->
<div id="modal" class="modal" role="dialog" aria-hidden="true">
  <div class="modal-content">
    <div class="modal-header">
      <div><strong id="modalTitle"></strong></div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="modalClose" class="btn">Đóng</button>
      </div>
    </div>
    <div class="modal-body" id="modalBody"></div>
  </div>
</div>

<!-- progress panel -->
<div id="progressPanel" class="progress-panel" aria-hidden="true">
  <div id="overallLabel" class="progress-label"><span>Upload tiến độ</span><span id="overallPercent">0%</span></div>
  <div class="progress-row">
    <div class="progress-bar-bg"><div id="overallBar" class="progress-bar-fill" style="width:0%"></div></div>
  </div>
  <div id="groupsContainer"></div>
  <div style="display:flex;justify-content:flex-end;gap:6px;margin-top:8px">
    <button id="closeProgressBtn" class="btn">Ẩn</button>
  </div>
</div>

<script>
/* CONFIG */
const WORKER_BASE = "https://shoes-worker.lapproak0.workers.dev";
const PREFIX = "Shoes";

/* DOM refs */
const statusEl = document.getElementById('status');
const tabsEl = document.getElementById('tabs');
const contentEl = document.getElementById('content');
const searchInput = document.getElementById('searchInput');
const refreshBtn = document.getElementById('refreshBtn');
const clearKeyBtn = document.getElementById('clearKeyBtn');
const selectActions = document.getElementById('selectActions');
const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
const modal = document.getElementById('modal');
const modalTitle = document.getElementById('modalTitle');
const modalBody = document.getElementById('modalBody');
const modalClose = document.getElementById('modalClose');

const progressPanel = document.getElementById('progressPanel');
const overallBar = document.getElementById('overallBar');
const overallPercent = document.getElementById('overallPercent');
const groupsContainer = document.getElementById('groupsContainer');
const closeProgressBtn = document.getElementById('closeProgressBtn');

/* state */
let manifestRaw = null;
let manifest = null;
let activeTab = 'all';
let selectedItems = new Set();

/* Admin key in session */
function getAdminKeySession() { return sessionStorage.getItem('admin_key_v1') || null; }
function setAdminKeySession(key) { if (!key) return sessionStorage.removeItem('admin_key_v1'); sessionStorage.setItem('admin_key_v1', key); }
function promptAdminKeyIfNeeded() {
  const existing = getAdminKeySession();
  if (existing) return existing;
  const k = prompt('Nhập ADMIN_KEY (sẽ lưu trong session cho phiên này):');
  if (!k) return null;
  const trimmed = k.trim();
  setAdminKeySession(trimmed);
  return trimmed;
}

/* UX helpers */
function logStatus(msg){ statusEl.textContent = msg; console.log(msg); }
function showModal(title, htmlOrNode) {
  modalTitle.textContent = title;
  if (typeof htmlOrNode === 'string') modalBody.innerHTML = htmlOrNode;
  else { modalBody.innerHTML = ''; modalBody.appendChild(htmlOrNode); }
  modal.classList.add('open'); modal.setAttribute('aria-hidden','false');
}
modalClose.onclick = ()=>{ modal.classList.remove('open'); modal.setAttribute('aria-hidden','true'); };
modal.onclick = (e)=>{ if (e.target === modal) modalClose.click(); };

/* normalize manifest */
function normalizeManifest(raw) {
  if (!raw) return { sizes: [] };
  if (Array.isArray(raw)) return { sizes: raw };
  if (raw.sizes && Array.isArray(raw.sizes)) {
    return {
      sizes: raw.sizes.map(s => ({
        size: String(s.size || s.name || "").trim(),
        barcodes: Array.isArray(s.barcodes) ? s.barcodes.map(b => ({ code: String(b.code || "").trim(), images: Array.isArray(b.images) ? b.images.slice() : [] })) : []
      }))
    };
  }
  const sizes = [];
  for (const [k, v] of Object.entries(raw)) {
    if (k === "meta" || k === "version") continue;
    if (v && typeof v === "object" && !Array.isArray(v)) {
      const barcodes = [];
      for (const [code, imgs] of Object.entries(v)) {
        if (Array.isArray(imgs)) barcodes.push({ code: String(code).trim(), images: imgs.slice() });
      }
      sizes.push({ size: String(k).trim(), barcodes });
    }
  }
  sizes.sort((a,b)=> {
    const ai = parseInt(a.size), bi = parseInt(b.size);
    if (!isNaN(ai) && !isNaN(bi)) return ai - bi;
    return a.size.localeCompare(b.size);
  });
  return { sizes };
}

/* fetch manifest */
async function fetchManifest({ forceRefresh=false }={}) {
  try {
    logStatus('Loading manifest...');
    if (forceRefresh) {
      const key = promptAdminKeyIfNeeded(); if (!key) { alert('Hủy: cần ADMIN_KEY'); return; }
      const r = await fetch(WORKER_BASE + '/refresh-manifest', { method:'POST', headers:{ 'x-api-key': key }});
      if (!r.ok) { const t = await r.text().catch(()=>r.statusText); throw new Error('Refresh failed: ' + t); }
      manifestRaw = await r.json();
    } else {
      const r = await fetch(WORKER_BASE + '/manifest.json', { cache:'no-store' });
      if (!r.ok) { const t = await r.text().catch(()=>r.statusText); throw new Error('manifest fetch ' + r.status); }
      manifestRaw = await r.json();
    }
    manifest = normalizeManifest(manifestRaw || {});
    logStatus('Loaded manifest (sizes: ' + manifest.sizes.length + ')');
    buildTabs();
  } catch (err) {
    console.error(err); logStatus('Không load được manifest: ' + err.message); contentEl.innerHTML='';
  }
}

/* Tabs & rendering (same as before) */
function buildTabs(){
  tabsEl.innerHTML = '';
  tabsEl.appendChild(createTabButton('Tất cả','all'));
  for (const s of manifest.sizes) tabsEl.appendChild(createTabButton(String(s.size), 'size:'+s.size));
  tabsEl.appendChild(createTabButton('Thêm','add'));
  const spacer = document.createElement('div'); spacer.style.flex='1'; tabsEl.appendChild(spacer);
  tabsEl.appendChild(createTabButton('Chọn để xóa','select-delete'));
  setActiveButton(); renderAccording();
}
function createTabButton(text, key) { const btn = document.createElement('button'); btn.className = 'tab' + (activeTab===key ? ' active' : ''); btn.textContent = text; btn.onclick = ()=>{ activeTab = key; setActiveButton(); renderAccording(); }; return btn; }
function setActiveButton() { document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active')); const label = activeTab==='all' ? 'Tất cả' : activeTab.startsWith('size:') ? activeTab.split(':')[1] : activeTab==='add' ? 'Thêm' : 'Chọn để xóa'; const btn = Array.from(document.querySelectorAll('.tab')).find(b=>b.textContent===label); if (btn) btn.classList.add('active'); }
function renderAccording(){ selectActions.style.display = 'none'; selectedItems.clear(); if (activeTab==='all') renderAll(); else if (activeTab.startsWith('size:')) renderSize(activeTab.split(':')[1]); else if (activeTab==='add') renderAdd(); else if (activeTab==='select-delete') renderSelectDelete(); }

/* Cards */
function makeCard(size, bc, withCheckbox=false) {
  const card = document.createElement('div'); card.className='card';
  if (withCheckbox) {
    const cb = document.createElement('input'); cb.type='checkbox'; cb.className='checkbox-select';
    const key = `${String(size).trim()}|${String(bc.code).trim()}`;
    cb.checked = selectedItems.has(key);
    cb.onchange = (e)=> { if (e.target.checked) selectedItems.add(key); else selectedItems.delete(key); };
    card.appendChild(cb);
  }
  const thumbName = (Array.isArray(bc.images) && bc.images.find(x=>/thumb/i.test(x))) || (Array.isArray(bc.images) ? bc.images[0] : null) || 'thumb.jpeg';
  const encSize = encodeURIComponent(String(size).trim());
  const encCode = encodeURIComponent(String(bc.code).trim());
  const src = `${WORKER_BASE}/${PREFIX}/${encSize}/${encCode}/${encodeURIComponent(thumbName)}`;
  const img = document.createElement('img'); img.src = src; img.alt = bc.code;
  img.onerror = ()=>{ img.style.opacity=0.6; img.style.objectFit='contain' };
  img.onclick = ()=> openDetails(size, bc);
  card.appendChild(img);

  const row = document.createElement('div'); row.className='barcode-row';
  const codeEl = document.createElement('div');
  codeEl.innerHTML = `<span class="barcode-strong">${bc.code}</span>`;
  row.appendChild(codeEl);

  const actions = document.createElement('div');
  const shareBtn = document.createElement('button'); shareBtn.className='btn'; shareBtn.textContent='Lưu/Share';
  shareBtn.onclick = ()=> shareMultipleImages(size, bc);
  actions.appendChild(shareBtn);
  row.appendChild(actions);
  card.appendChild(row);
  return card;
}

/* Details modal */
function openDetails(size, bc) {
  modalTitle.textContent = `Size ${size} — ${bc.code}`;
  modalBody.innerHTML = '';
  const imgs = bc.images || [];
  const div = document.createElement('div'); div.className = 'two-col';
  for (const fn of imgs) {
    const im = document.createElement('img');
    im.src = `${WORKER_BASE}/${PREFIX}/${encodeURIComponent(String(size).trim())}/${encodeURIComponent(String(bc.code).trim())}/${encodeURIComponent(fn)}`;
    div.appendChild(im);
  }
  modalBody.appendChild(div); modal.classList.add('open'); modal.setAttribute('aria-hidden','false');
}

/* Render lists */
function renderAll(){ contentEl.innerHTML=''; for (const s of manifest.sizes) { const h=document.createElement('div'); h.className='section-title'; h.textContent='Size '+s.size; contentEl.appendChild(h); const grid=document.createElement('div'); grid.className='grid'; for (const bc of s.barcodes) grid.appendChild(makeCard(s.size, bc, false)); contentEl.appendChild(grid); } }
function renderSize(sizeStr){ contentEl.innerHTML=''; const s = manifest.sizes.find(x=>String(x.size)===String(sizeStr)); if (!s) { contentEl.innerHTML='<div class="muted">Không có size này</div>'; return; } const grid=document.createElement('div'); grid.className='grid'; for (const bc of s.barcodes) grid.appendChild(makeCard(s.size, bc, false)); contentEl.appendChild(grid); }
function renderSelectDelete(){ contentEl.innerHTML=''; selectActions.style.display='block'; selectedItems.clear(); for (const s of manifest.sizes) { const h=document.createElement('div'); h.className='section-title'; h.textContent='Size '+s.size; contentEl.appendChild(h); const grid=document.createElement('div'); grid.className='grid'; for (const bc of s.barcodes) grid.appendChild(makeCard(s.size, bc, true)); contentEl.appendChild(grid); } }

/* Delete selected (permanent) */
deleteSelectedBtn.onclick = async ()=> {
  if (selectedItems.size === 0) return alert('Chưa chọn mục để xóa');
  if (!confirm('Xóa các mục đã chọn? (Vĩnh viễn, không thể hoàn tác)')) return;
  const key = promptAdminKeyIfNeeded(); if (!key) { alert('Hủy: cần ADMIN_KEY'); return; }
  const items = Array.from(selectedItems).map(s => { const [size, barcode] = s.split('|'); return { size, barcode }; });
  try {
    const r = await fetch(WORKER_BASE + '/bulk-delete', { method:'POST', headers:{ 'Content-Type':'application/json', 'x-api-key': key }, body: JSON.stringify({ items })});
    if (!r.ok) { const t = await r.text().catch(()=>r.statusText); throw new Error('Delete failed: ' + t); }
    const j = await r.json();
    alert('Xóa hoàn tất. Deleted keys: ' + (j.totalDeleted || 0));
    await fetchManifest();
    activeTab = 'all'; renderAccording();
  } catch (err) { console.error(err); alert('Lỗi xóa: ' + err.message); }
};

/* Image convert helper (same as before) */
async function convertImageFileToJpeg(file, maxWidth=1600, quality=0.80) {
  if (!file.type.startsWith('image/')) return file;
  try {
    const imgBitmap = await createImageBitmap(file);
    const scale = imgBitmap.width > maxWidth ? maxWidth / imgBitmap.width : 1;
    const w = Math.round(imgBitmap.width * scale);
    const h = Math.round(imgBitmap.height * scale);
    const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d'); ctx.drawImage(imgBitmap, 0, 0, w, h);
    const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', quality));
    const newName = (file.name.replace(/\.[^/.]+$/, '') || 'image') + '.jpeg';
    return new File([blob], newName, { type: 'image/jpeg' });
  } catch (e) {
    console.warn('convertImageFileToJpeg failed', e);
    return file;
  }
}

/* --- UPLOAD with progress using XHR --- */
function uploadFileWithProgress(url, file, onProgress) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('PUT', url, true);
    if (file.type) xhr.setRequestHeader('Content-Type', file.type);
    xhr.upload.onprogress = (ev) => {
      if (ev.lengthComputable) onProgress(ev.loaded, ev.total);
    };
    xhr.onload = () => {
      if (xhr.status >= 200 && xhr.status < 300) resolve({ ok: true, status: xhr.status });
      else reject(new Error('Upload failed: ' + xhr.status + ' ' + xhr.statusText + ' - ' + xhr.responseText));
    };
    xhr.onerror = () => reject(new Error('Network error during upload'));
    xhr.send(file);
  });
}

/* Progress UI helpers */
function showProgressPanel() { progressPanel.classList.add('open'); progressPanel.setAttribute('aria-hidden','false'); }
function hideProgressPanel() { progressPanel.classList.remove('open'); progressPanel.setAttribute('aria-hidden','true'); }
closeProgressBtn.onclick = ()=> hideProgressPanel();

function createGroupProgress(groupId, label) {
  const row = document.createElement('div'); row.className = 'progress-row'; row.id = 'group-' + groupId;
  const lbl = document.createElement('div'); lbl.className = 'progress-label'; lbl.innerHTML = `<span>${label}</span><span class="group-percent">0%</span>`;
  const barBg = document.createElement('div'); barBg.className = 'progress-bar-bg';
  const barFill = document.createElement('div'); barFill.className = 'progress-bar-fill';
  barBg.appendChild(barFill);
  const fileList = document.createElement('div'); fileList.className = 'file-list' ;
  row.appendChild(lbl); row.appendChild(barBg); row.appendChild(fileList);
  groupsContainer.appendChild(row);
  return { row, lbl, barFill, fileList };
}
function updateGroupProgress(groupEl, loaded, total) {
  const pct = total ? Math.round(loaded / total * 100) : 0;
  groupEl.barFill.style.width = pct + '%';
  const percentEl = groupEl.row.querySelector('.group-percent');
  if (percentEl) percentEl.textContent = pct + '%';
}
function addFileStatus(fileListEl, fname) {
  const div = document.createElement('div');
  div.className = 'file-status-row';
  div.innerHTML = `<div style="display:flex;justify-content:space-between"><div>${fname}</div><div class="file-status">0%</div></div><div class="progress-bar-bg" style="margin-top:6px"><div class="progress-bar-fill" style="width:0%"></div></div>`;
  fileListEl.appendChild(div);
  return { container: div, progressFill: div.querySelector('.progress-bar-fill'), statusEl: div.querySelector('.file-status') };
}
function updateFileProgress(fileObj, loaded, total) {
  const pct = total ? Math.round(loaded / total * 100) : 0;
  fileObj.progressFill.style.width = pct + '%';
  fileObj.statusEl.textContent = pct + '%';
}
function updateOverallProgress(loaded, total) {
  const pct = total ? Math.round(loaded / total * 100) : 0;
  overallBar.style.width = pct + '%';
  overallPercent.textContent = pct + '%';
}

/* --- Add tab (with progress integrated) --- */
function renderAdd() {
  contentEl.innerHTML = '';
  const box = document.createElement('div'); box.style.background='#fff'; box.style.padding='12px'; box.style.borderRadius='8px';

  const sizes = manifest.sizes.map(s=>s.size);
  const sizeSelect = document.createElement('select'); sizeSelect.style.margin='6px';
  sizes.forEach(s=> { const o=document.createElement('option'); o.value=s; o.textContent=s; sizeSelect.appendChild(o); });

  const codeInput = document.createElement('input'); codeInput.type='text'; codeInput.placeholder='Barcode (146888)';
  const thumbInput = document.createElement('input'); thumbInput.type='file'; thumbInput.accept='image/*';
  const detailInput = document.createElement('input'); detailInput.type='file'; detailInput.accept='image/*'; detailInput.multiple = true;

  const folderLabel = document.createElement('div'); folderLabel.className='small muted'; folderLabel.textContent = 'Hoặc: chọn folder "Shoes" (desktop Chrome/Edge hỗ trợ)';
  const folderInput = document.createElement('input'); folderInput.type='file'; folderInput.webkitdirectory = true; folderInput.directory = true; folderInput.multiple = true;
  folderInput.style.display = 'block'; folderInput.style.marginTop = '6px';

  const overwriteChkLabel = document.createElement('label'); overwriteChkLabel.innerHTML = '<input id="overwriteAdd" type="checkbox"> Ghi đè nếu tồn tại';

  const btnPreview = document.createElement('button'); btnPreview.className='btn'; btnPreview.textContent='Xem ảnh (preview)';
  const btnSave = document.createElement('button'); btnSave.className='btn'; btnSave.textContent='Upload (presigned)';

  btnPreview.onclick = ()=> {
    const details = Array.from(detailInput.files || []);
    const t = thumbInput.files && thumbInput.files[0];
    const div = document.createElement('div');
    if (t) { const im=document.createElement('img'); im.src = URL.createObjectURL(t); im.style.maxWidth='160px'; div.appendChild(im); }
    details.forEach(f=> { const im=document.createElement('img'); im.src=URL.createObjectURL(f); im.style.maxWidth='120px'; im.style.margin='6px'; div.appendChild(im); });
    showModal('Preview ảnh', div);
  };

  async function uploadPreparedGroups(preparedGroups, adminKey) {
    // preparedGroups: [{ size, barcode, prepared: [{file, remoteName}] }]
    // compute overall total bytes
    let overallTotal = 0;
    for (const g of preparedGroups) for (const p of g.prepared) overallTotal += p.file.size;
    let overallLoaded = 0;
    showProgressPanel();
    groupsContainer.innerHTML = '';
    updateOverallProgress(0, overallTotal);

    for (const [gi, g] of preparedGroups.entries()) {
      const gid = `${g.size}|${g.barcode}|${gi}`;
      const groupEl = createGroupProgress(gid, `Size ${g.size} — ${g.barcode}`);
      // compute group total
      const groupTotal = g.prepared.reduce((s,p)=>s + p.file.size, 0);
      let groupLoaded = 0;
      // add file entries
      const fileObjs = [];
      for (const p of g.prepared) {
        fileObjs.push(addFileStatus(groupEl.fileList, p.remoteName));
      }
      // presign
      const filenames = g.prepared.map(p => p.remoteName);
      const presignRes = await fetch(WORKER_BASE + '/presign-upload', { method:'POST', headers:{ 'Content-Type':'application/json', 'x-api-key': adminKey }, body: JSON.stringify({ size: g.size, barcode: g.barcode, files: filenames, expiresIn: 3600 })});
      if (!presignRes.ok) { const t = await presignRes.text().catch(()=>presignRes.statusText); throw new Error('Presign failed: ' + t); }
      const presignJson = await presignRes.json();
      const urls = presignJson.urls || {};

      // upload files sequentially per group to simplify progress (could be parallel)
      for (let i = 0; i < g.prepared.length; i++) {
        const p = g.prepared[i];
        const fileObj = fileObjs[i];
        const url = urls[p.remoteName];
        if (!url) throw new Error('Missing presigned URL for ' + p.remoteName);
        try {
          await uploadFileWithProgress(url, p.file, (loaded, total) => {
            // update per-file
            updateFileProgress(fileObj, loaded, total);
            // compute delta to update group & overall: can't easily compute delta from repeated events,
            // so approximate by summing current file loaded + previously completed file sizes.
            // We'll keep track using groupLoaded and overallLoaded when each file completes.
            // But here update group bar by summing file progress:
            // recompute groupLoaded from fileObjs (sum status * size fraction)
            // Simpler: compute pct for this file and estimate group progress incrementally:
            const filePct = total ? loaded / total : 0;
            const partialSum = groupLoaded + loaded;
            updateGroupProgress(groupEl, Math.min(groupLoaded + loaded, groupTotal), groupTotal);
            // update overall by summing all file progress from groups processed + this loaded
            const estimateOverall = overallLoaded + loaded;
            updateOverallProgress(estimateOverall, overallTotal);
          });
          // file uploaded successfully -> mark 100%
          updateFileProgress(fileObj, p.file.size, p.file.size);
          groupLoaded += p.file.size;
          overallLoaded += p.file.size;
          updateGroupProgress(groupEl, groupLoaded, groupTotal);
          updateOverallProgress(overallLoaded, overallTotal);
          fileObj.statusEl.textContent = 'OK';
        } catch (e) {
          fileObj.statusEl.textContent = 'ERR';
          console.error('Upload file error', e);
          throw e;
        }
      }

      // done group -> call complete-upload
      const complete = await fetch(WORKER_BASE + '/complete-upload', { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ size: g.size, barcode: g.barcode })});
      if (!complete.ok) { const t = await complete.text().catch(()=>complete.statusText); throw new Error('Complete-upload failed: ' + t); }
    }
    // finished all
    updateOverallProgress(overallLoaded, overallTotal);
    setTimeout(()=> { hideProgressPanel(); }, 800);
  }

  btnSave.onclick = async ()=> {
    const overwrite = document.getElementById('overwriteAdd').checked;
    const adminKey = promptAdminKeyIfNeeded();
    if (!adminKey) { alert('Hủy: cần ADMIN_KEY'); return; }

    // folder mode if folderInput used
    if (folderInput.files && folderInput.files.length > 0) {
      const files = Array.from(folderInput.files);
      const groups = {};
      for (const f of files) {
        const rel = f.webkitRelativePath || f.name;
        const parts = rel.split('/').filter(Boolean);
        let idx = 0;
        if (parts[0] && parts[0].toLowerCase() === 'shoes') idx = 1;
        if (parts.length - idx < 3) { console.warn('Skipping invalid path', rel); continue; }
        const size = parts[idx].trim();
        const barcode = parts[idx+1].trim();
        const fname = parts.slice(idx+2).join('/');
        if (!groups[size]) groups[size] = {};
        if (!groups[size][barcode]) groups[size][barcode] = [];
        groups[size][barcode].push({ file: f, relPath: fname });
      }

      // prepare groups to upload: convert files
      const preparedGroups = [];
      for (const size of Object.keys(groups)) {
        for (const barcode of Object.keys(groups[size])) {
          const items = groups[size][barcode];
          if (overwrite) {
            try {
              await fetch(WORKER_BASE + '/bulk-delete', { method:'POST', headers:{ 'Content-Type':'application/json', 'x-api-key': adminKey }, body: JSON.stringify({ items: [{ size, barcode }] })});
            } catch(e) { console.warn('overwrite delete failed', e); }
          }
          const prepared = [];
          for (const it of items) {
            const processed = await convertImageFileToJpeg(it.file);
            let remoteName = it.relPath || it.file.name;
            const base = remoteName.split('/').pop();
            if (/thumb/i.test(base)) remoteName = remoteName.replace(/[^/]*$/, 'thumb.jpeg');
            else {
              if (processed.name.endsWith('.jpeg') && !/\.jpe?g$/i.test(base)) remoteName = remoteName.replace(/[^/]*$/, processed.name);
              else remoteName = remoteName.replace(/[^/]*$/, base);
            }
            prepared.push({ file: processed, remoteName });
          }
          preparedGroups.push({ size, barcode, prepared });
        }
      }

      if (preparedGroups.length === 0) return alert('Không có file hợp lệ trong folder');
      try {
        await uploadPreparedGroups(preparedGroups, adminKey);
        await fetchManifest();
        alert('Upload folder hoàn tất');
      } catch (e) {
        console.error(e); alert('Upload folder lỗi: ' + e.message);
      }
      return;
    }

    // single barcode flow
    const sizeVal = sizeSelect.value;
    const barcodeVal = (codeInput.value||'').trim();
    if (!sizeVal) return alert('Chọn size');
    if (!barcodeVal) return alert('Nhập barcode');
    const details = Array.from(detailInput.files || []);
    if (details.length === 0) return alert('Chọn ít nhất 1 ảnh detail');

    if (overwrite) {
      try {
        await fetch(WORKER_BASE + '/bulk-delete', { method:'POST', headers:{ 'Content-Type':'application/json', 'x-api-key': adminKey }, body: JSON.stringify({ items: [{ size: sizeVal, barcode: barcodeVal }] })});
      } catch(e) { console.warn('overwrite delete failed', e); }
    }

    // prepare files
    const filesToUpload = [];
    if (thumbInput.files && thumbInput.files[0]) {
      const t = await convertImageFileToJpeg(thumbInput.files[0]);
      const thumbFile = new File([await t.arrayBuffer()], 'thumb.jpeg', { type: 'image/jpeg' });
      filesToUpload.push(thumbFile);
    }
    for (const f of details) {
      const p = await convertImageFileToJpeg(f);
      filesToUpload.push(p);
    }

    // prepare single group
    const group = { size: sizeVal, barcode: barcodeVal, prepared: filesToUpload.map(f => ({ file: f, remoteName: f.name })) };
    try {
      await uploadPreparedGroups([group], adminKey);
      await fetchManifest();
      alert('Upload hoàn tất: ' + barcodeVal);
    } catch (e) {
      console.error(e); alert('Upload lỗi: ' + e.message);
    }
  };

  const wrap = document.createElement('div');
  wrap.appendChild(document.createTextNode('Size: ')); wrap.appendChild(sizeSelect);
  wrap.appendChild(document.createElement('br'));
  wrap.appendChild(document.createTextNode('Barcode: ')); wrap.appendChild(codeInput);
  wrap.appendChild(document.createElement('br'));
  wrap.appendChild(document.createTextNode('Thumbnail: ')); wrap.appendChild(thumbInput);
  wrap.appendChild(document.createElement('br'));
  wrap.appendChild(document.createTextNode('Detail images: ')); wrap.appendChild(detailInput);
  wrap.appendChild(document.createElement('br'));
  wrap.appendChild(folderLabel); wrap.appendChild(folderInput);
  wrap.appendChild(document.createElement('br'));
  wrap.appendChild(overwriteChkLabel);
  wrap.appendChild(document.createElement('br'));
  wrap.appendChild(btnPreview); wrap.appendChild(btnSave);

  box.appendChild(wrap); contentEl.appendChild(box);
}

/* Search + Share + merge (unchanged) */
searchInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') doSearch(); });
function doSearch(){ const q = (searchInput.value||'').trim().toLowerCase(); if (!q) { alert('Nhập barcode để tìm'); return; } const matches=[]; for (const s of manifest.sizes) for (const b of s.barcodes) if (String(b.code).toLowerCase().includes(q)) matches.push({ size: s.size, barcode: b }); if (matches.length===0) { alert('Không tìm thấy'); return; } let html=`<div>Found ${matches.length} kết quả</div>`; matches.forEach(m=> html += `<div style="margin-top:8px"><strong>${m.barcode.code}</strong> — Size ${m.size} <button class="btn" data-size="${m.size}" data-code="${m.barcode.code}">Xem</button></div>`); showModal('Kết quả tìm kiếm', html); modalBody.querySelectorAll('button[data-size]').forEach(btn=>btn.onclick=(ev)=>{ const s=ev.target.dataset.size; const c=ev.target.dataset.code; modalClose.click(); activeTab='size:'+s; setActiveButton(); renderSize(s); setTimeout(()=>{ const cards = Array.from(document.querySelectorAll('.card')); const card = cards.find(cd=>cd.textContent.includes(c)); if (card) card.scrollIntoView({behavior:'smooth', block:'center'}); },300); }); }

async function shareMultipleImages(size, barcodeObj) {
  try {
    const encSize = encodeURIComponent(String(size).trim());
    const encCode = encodeURIComponent(String(barcodeObj.code).trim());
    const urls = (barcodeObj.images || []).map(f => `${WORKER_BASE}/${PREFIX}/${encSize}/${encCode}/${encodeURIComponent(f)}`);
    const files = [];
    for (const u of urls) {
      const r = await fetch(u, { mode: 'cors' });
      if (!r.ok) throw new Error(`Fetch failed ${r.status} ${u}`);
      const blob = await r.blob();
      const fname = decodeURIComponent(u.split('/').pop());
      files.push(new File([blob], fname, { type: blob.type }));
    }
    if (navigator.canShare && navigator.canShare({ files })) { await navigator.share({ files, title: 'Images ' + barcodeObj.code }); return; }
    else { await mergeImagesAndOpen(urls, size, barcodeObj); }
  } catch (err) {
    console.error('shareMultipleImages error', err);
    alert('Không thể share nhiều ảnh trực tiếp: ' + err.message + '\nSẽ thử mở ảnh ghép để lưu thủ công.');
    try { const encSize = encodeURIComponent(String(size).trim()); const encCode = encodeURIComponent(String(barcodeObj.code).trim()); const urls = (barcodeObj.images || []).map(f => `${WORKER_BASE}/${PREFIX}/${encSize}/${encCode}/${encodeURIComponent(f)}`); await mergeImagesAndOpen(urls, size, barcodeObj); } catch(e) { console.error('fallback merge failed', e); alert('Fallback cũng thất bại: ' + e.message); }
  }
}
async function mergeImagesAndOpen(urls, size, barcodeObj) {
  try {
    const bitmaps = [];
    for (const u of urls) {
      const r = await fetch(u, { mode:'cors' });
      if (!r.ok) throw new Error('Fetch failed ' + r.status + ' ' + u);
      const blob = await r.blob();
      const bmp = await createImageBitmap(blob);
      bitmaps.push(bmp);
    }
    const gap = 8; const colHeights=[0,0], colMaxW=[0,0];
    for (let i=0;i<bitmaps.length;i++){ const col=i%2; colMaxW[col]=Math.max(colMaxW[col], bitmaps[i].width); colHeights[col]+=bitmaps[i].height+gap; }
    const maxColWidth=900; const scale0 = colMaxW[0] ? Math.min(1, maxColWidth/colMaxW[0]) : 1; const scale1 = colMaxW[1] ? Math.min(1, maxColWidth/colMaxW[1]) : 1;
    const colW = Math.round(Math.max(colMaxW[0]*scale0, colMaxW[1]*scale1)); const canvasW = colW*2 + gap; const canvasH = Math.round(Math.max(colHeights[0]*scale0, colHeights[1]*scale1) || 400);
    const canvas = document.createElement('canvas'); canvas.width=canvasW; canvas.height=canvasH; const ctx = canvas.getContext('2d'); ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvasW,canvasH);
    const y=[0,0];
    for (let i=0;i<bitmaps.length;i++){ const bm=bitmaps[i]; const col=i%2; const scale = col===0?scale0:scale1; const drawW=Math.round(bm.width*scale); const drawH=Math.round(bm.height*scale); const x = col===0?0:colW+gap; ctx.drawImage(bm,0,0,bm.width,bm.height,x,y[col],drawW,drawH); y[col]+=drawH+gap; }
    const blob = await new Promise(res=>canvas.toBlob(res,'image/png',0.92));
    const url = URL.createObjectURL(blob); const w = window.open(url,'_blank'); if (!w) { const a=document.createElement('a'); a.href=url; a.target='_blank'; document.body.appendChild(a); a.click(); a.remove(); }
    setTimeout(()=>URL.revokeObjectURL(url),60000);
  } catch(e) { console.error('mergeImagesAndOpen error', e); throw e; }
}

/* Refresh & Clear key */
refreshBtn.onclick = async ()=> { try { const key = promptAdminKeyIfNeeded(); if (!key) { alert('Hủy: cần ADMIN_KEY'); return; } const r = await fetch(WORKER_BASE + '/refresh-manifest', { method:'POST', headers:{ 'x-api-key': key }}); if (!r.ok) { const t = await r.text().catch(()=>r.statusText); throw new Error('Refresh failed: ' + t); } await fetchManifest(); alert('Manifest rebuilt'); } catch(err){ console.error(err); alert('Refresh error: ' + err.message); } };
clearKeyBtn.onclick = ()=> { setAdminKeySession(null); alert('Admin key đã xóa khỏi session'); };

/* Init */
async function init() { await fetchManifest(); }
init();

</script>
</body>
</html>
